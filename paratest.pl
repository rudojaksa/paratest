#!/usr/bin/perl
# include "CONFIG.pl"
# include "help.pl"
# include "support.pl"
# include "verbose.pl"
use Time::HiRes qw(usleep);
print STDERR "\n";

# --------------------------------------------------------------------------------- HELP
$HELP_MAIN=<<EOF;

NAME
    paratest - parametric test of program

USAGE
    paratest [OPTIONS] -r PROGRAM [CC(PROGRAM-OPTIONS)]

DESCRIPTION
    Repeatedly run arbitrary program with different arguments. The sequence
    of parameters supplied into arguments of program can be either linear or
    exponentially-growing for logarithmic x-axis plots.

    To allow full utilization of the CPU and cache, tested programs are
    executed in sequence, not in parallel.  However, multiple adequately
    configured paratests can be run in parallel to fully squeeze the
    multi-core CPU, when the performance available to the tested program
    is not important.

OPTIONS
           -h  This help.
           -v  Extra verbose.
           -d  Debug output.
           -q  Query mode, only report what to run.
           -a  Include all individual tests results into log.
      -n NAME  Name of test, output file will be CC(NAME.log).
      -k KEYS  Comma separated list of keys to log.
 -r PROG ARGS  Run program PROG with arguments ARGS.
         -f5d  Default numbers-format for logs (see KEYS).

       -p=STR  Parameter name (default CC(A)).
      -A1=NUM  Start.
      -A2=NUM  Stop.
       -s=NUM  Step, or log multiplayer, might use %.
       -n=NUM  Number of steps.
         -log  Logarithmic schedule (default linear).
      -dp=NUM  Decimal precision of A (default none).
      -bs=NUM  Next A only after surpassing this batch step (default none).
      -bS=NUM  Stop exactly on the batch steps (none). 

      -sl=NUM  Sleep time between runs, decimal seconds (default none).
      -eq=NUM  Number of concurrent equal runs.
 CC(-rnd=NUM:NUM)  Number of concurrent randomized runs and radius.
               Radius can be relative to the A parameter if given as %.
    -jrn=PATH  Paths to journal files to use.
    -log=PATH  Paths to log files to use.

PROGRAM OPTIONS
    Use the CC(A) letter to incorporate the tested parameter into
    program arguments, like: CW(nntrain -n test-)CC(A)CW( -t 146-)CC(A)CW(-3)

KEYS
    The CW(-k mcups:f2d,amae:maxmax,amae:maxavgmin) specifies three columns to
    store: the mcups and twice the amae variables from logs and journals. 
    The keys are comma separated, and optionally after a colon every key can
    carry its specs.  They can specify formatting of stored variable or
    aggregation method.  The aggregation has three levels:

      CC(level-1)  in-file aggregation, for log-files generated by tested
               programs,
      CC(level-2)  between-several-files aggregation, if more logs/journals
               are specified,
      CC(level-3)  between-tests aggregation, if concurrent or randomized
               runs were requested.

    The CW(maxavgmin) by its order specifies the CC(max) aggregation on level-1,
    the CC(avg) on level-2 and the CC(min) on level-3.  If no level-3 method is
    specified the level-2 will be reused.  The CC(min) is default for level-1.
    Available aggregation and formatting methods are:

          CC(min)  minimum, also as an alias CC(l),
          CC(max)  maximum, also as an alias CC(h),
          CC(avg)  average, also as an alias CC(a),
          CC(f5d)  specifies max five decimal places to be stored,
          CC(f5D)  zero-padded exactly five decimal places.

EOF

# ------------------------------------------------------------------------- PROGRAM ARGS

# save progrom an its args
our @PROG;
for($i=0; $i<=$#ARGV; $i++) {
  next if $ARGV[$i] eq "";
  if($ARGV[$i] eq "-r") {
    $ARGV[$i] = "";
    for($j=$i+1; $j<=$#ARGV; $j++) {
      push @PROG,$ARGV[$j];
      $ARGV[$j] = ""; }}}

# -------------------------------------------------------------------------------- ARGVS
foreach(@ARGV) { if($_ eq "-h") { printhelp($HELP_MAIN); exit 0; }}
foreach(@ARGV) { if($_ eq "-v") { $VERBOSE=1; $_=""; last; }}
foreach(@ARGV) { if($_ eq "-d") { $DEBUG=1; $_=""; last; }}
foreach(@ARGV) { if($_ eq "-q") { $QUERY=1; $_=""; last; }}
foreach(@ARGV) { if($_ eq "-a") { $ALLOUT=1; $_=""; last; }}

foreach(@ARGV) { if($_ =~ /^-f([0-9]+[dD])$/) { $DEFMT=$1; $_=""; last; }}

# name
our $NAME = "paratest";
for($i=0; $i<$#ARGV; $i++) {
  next if $ARGV[$i] eq "";
  if($ARGV[$i] eq "-n") {
    $NAME = $ARGV[$i+1];
    $ARGV[$i] = ""; $ARGV[$i+1] = ""; last; }}

our $PAR1;  foreach(@ARGV) { if(/^-p=(.*)$/)   { $PAR1=$1; $_=""; last; }}
our $A1;    foreach(@ARGV) { if(/^-A1=(.*)$/)  { $A1=0+$1; $_=""; last; }}
our $A2;    foreach(@ARGV) { if(/^-A2=(.*)$/)  { $A2=0+$1; $_=""; last; }}
our $STEP;  foreach(@ARGV) { if(/^-s=(.*)$/)   { $STEP=$1; $_=""; last; }}
our $STEPS; foreach(@ARGV) { if(/^-n=(.*)$/)   { $STEPS=0+$1; $_=""; last; }}
our $XLOG;  foreach(@ARGV) { if($_ eq "-log")  { $XLOG=1; $_=""; last; }}
our $PREC;  foreach(@ARGV) { if(/^-dp=(.*)$/)  { $PREC=0+$1; $_=""; last; }}

our $BINC = 0;
our $BAFT;  foreach(@ARGV) { if(/^-bs=(.*)$/)  { $BINC=0+$1; $BAFT=1; $_=""; last; }}
our $BAT;   foreach(@ARGV) { if(/^-bS=(.*)$/)  { $BINC=0+$1; $BAT=1; $_=""; last; }}

our $SLEEP; foreach(@ARGV) { if(/^-sl=(.*)$/)  { $SLEEP=0+$1; $_=""; last; }}

our $KMIN;  foreach(@ARGV) { if(/^-min$/) { $KMIN=1; $_=""; last; }}
our $KMAX;  foreach(@ARGV) { if(/^-max$/) { $KMAX=1; $_=""; last; }}
our $KAVG;  foreach(@ARGV) { if(/^-avg$/) { $KAVG=1; $_=""; last; }}

our @PJRN;  foreach(@ARGV) { if(/^-jrn=(.*)$/) { push @PJRN,$1; $_=""; }}
our @PLOG;  foreach(@ARGV) { if(/^-log=(.*)$/) { push @PLOG,$1; $_=""; }}

# keys
our @KEYS;
for($i=0; $i<$#ARGV; $i++) {
  next if $ARGV[$i] eq "";
  if($ARGV[$i] eq "-k") {
    push @KEYS,split(/,/,$ARGV[$i+1]);
    $ARGV[$i] = ""; $ARGV[$i+1] = ""; }}

# concurrent runs
our $EQUAL=1;
foreach(@ARGV) { if(/^-eq=(.*)$/)  { $EQUAL=0+$1; $_=""; last; }}

# randomized runs
our $RAND;
our $RAD=1;
our $RADMAX;
foreach(@ARGV) { if(/^-rnd=([^:]*)(:(.*))?$/) {
  $RAND=0+$1;
  $RAD=$3 if defined $3;
  $_=""; last; }}
if($RAD=~/%/) {
  if($RAD=~s/%<(.*)/%/) { $RADMAX = 0+$1; }
  $RAD = 0+$RAD; $RAD .= "%"; }
else {
  $RAD = 0+$RAD; }

# unknown args
my $ok=1;
foreach(@ARGV) {
  next if $_ eq "";
  error("unknown arg",$_);
  $ok=0; }
exit 1 if not $ok;

# --------------------------------------------------------------------------------- AUTO

# multiplier resolver
if(defined $STEP) {
  my $step = 0 + $STEP;
  $step /= 100 if $STEP =~ /%$/;
  $step += 1 if $step <= 1;
  $STEP = $step; }

# decimal precisions
$PREC=0 if not defined $PREC;
our $APREC = $PREC;

# batch step
our $ABINC = $BINC;
our $ABAT = $BAT;

# parameter name
$PAR1 = "A" if not defined $PAR1;

# A-parameter
our $ALOG; $ALOG=1 if defined $XLOG;
our $ASTEP; $ASTEP=$STEP if defined $STEP;
our $ASTEPS; $ASTEPS=$STEPS if defined $STEPS;

# log base
our $ABASE;
if(defined $ALOG) {
  if(defined $ASTEP) { $ABASE = $ASTEP; }
  else		     { $ABASE = 2; }}

# end not specified
$ASTEPS = 100 if not defined $A2 and not defined $ASTEPS;

# ------------------------------------------------------------------------------ SUMMARY

verbose("name",$NAME);

my $alog=""; $alog="log " if defined $ALOG;
my $a1=""; $a1="${CK_}A1=$CD_$A1 " if defined $A1;
my $a2=""; $a1="${CK_}A2=$CD_$A2 " if defined $A2;
my $as=""; $as="${CK_}step=$CD_$ASTEP " if defined $ASTEP;
my $an=""; $an="${CK_}steps=$CD_$ASTEPS " if defined $ASTEPS;

verbose("A range","$alog$a1$a2$as$an");

if(defined $RAND and $RAND>=1) {
  my $rmax=""; $rmax=" ${CK_}maxradius=$CD_$RADMAX" if defined $RADMAX;
  verbose("randomize","${CK_}runs=$CD_$RAND ${CK_}radius=$CD_$RAD$rmax"); }

my $prog = "";
$prog .= "$_ " foreach @PROG;
$prog =~ s/$PAR1/${CC_}$PAR1$CD_/g;

verbose("program",$prog);

my $pjrn = "";
$pjrn .= "$_ " foreach @PJRN;
$pjrn =~ s/$PAR1/${CC_}$PAR1$CD_/g;

verbose("journals",$pjrn) if @PJRN;

my $plog = "";
$plog .= "$_ " foreach @PLOG;
$plog =~ s/$PAR1/${CC_}$PAR1$CD_/g;

verbose("logs",$plog) if @PLOG;

my $keys;
foreach(@KEYS) {
  (my $k = $_) =~ s/(:.*)$/$CK_$1$CD_/;
  $keys .= "$k "; }

verbose("keys",$keys);

# -------------------------------------------------------------------- KEYS SPECS PARSER
our %KFMT;  # key format
our %KM1;   # key 1st level-1 in-file mode
our %KM2;   # key 2nd level-2 between-files mode
our %KM3;   # key 3rd level-3 between-tests mode
our %KM1d;  # whether the mode is default or explicitly reqeusted
our %KM2d;  # whether the mode is default or explicitly reqeusted
our %KM3d;  # whether the mode is default or explicitly reqeusted
my $ok = 1; # whether all specs were recognized

# multiple keys with same keyname
my @knames;
my %nname;
foreach my $k (@KEYS) {
  $k =~ /^([^:]*)(:.*)?$/;
  my ($k1,$k2) = ($1,$2);
  if(inar \@knames,$k1) {
    $nname{$k1}++;
    $k = "$k1~$nname{$k1}$k2"; }
  else {
    push @knames,$k1;
    $nname{$k1} = 1; }}

# aliases
sub kalias {
  my $a = $_[0];
  my $k = $a;
  $k = "min" if $a eq "l";
  $k = "max" if $a eq "h";
  $k = "avg" if $a eq "a";
  return $k; }

# parser
foreach my $k (@KEYS) {
  my $fmt;
  my $km1;
  my $km2;
  my $km3;
  my $spc;
  $spc = $1 if $k =~ s/:(.*)$//;

  $fmt = "$1d" if $spc =~ s/f([0-9]+)d//;
  $fmt = "$1D" if $spc =~ s/f([0-9]+)D//;

  $km1 = kalias $1 if $spc =~ s/(avg|min|max|l|h|a)//;
  $km2 = kalias $1 if $spc =~ s/(avg|min|max|l|h|a)//;
  $km3 = kalias $1 if $spc =~ s/(avg|min|max|l|h|a)//;

  if($spc ne "") {
    error("unknown spec","$k:$spc");
    $ok=0; }

  if(not $km1) { $km1 = "min"; $KM1d{$k} = 1; }
  if(not $km2) { $km2 = $km1;  $KM2d{$k} = 1; }
  if(not $km3) { $km3 = $km2;  $KM3d{$k} = 1; }

  $KM1{$k}  = $km1;
  $KM2{$k}  = $km2;
  $KM3{$k}  = $km3;
  $KFMT{$k} = $fmt if defined $fmt; }

# default format
if(defined $DEFMT) {
  foreach my $k (@KEYS) {
    if(not defined $KFMT{$k}) {
      $KFMT{$k} = $DEFMT; }}} 

# verbose
for(my $i=0; $i<=$#KEYS; $i++) {
  my $ii = fth $i+1;
  my $k = $KEYS[$i];
  my $kk = $k; $kk = "$1$CK_$2$CD_" if $k =~ /^(.*)~([0-9]+)$/;
  my $c1 = $CK_; $c1 = $CC_ if not $KM1d{$k};
  my $c2 = $CK_; $c2 = $CC_ if not $KM2d{$k};
  my $c3 = $CK_; $c3 = $CC_ if not $KM3d{$k};
  my $s1 = " $c1$KM1{$k}$CD_";	 $s1="" if scalar(@PLOG) < 2; # no level-1 aggregation for journals yet
  my $s2 = " $c2$KM2{$k}$CD_";	 $s2="" if scalar(@PJRN) + scalar(@PLOG) < 2;
  my $s3 = " $c3$KM3{$k}$CD_";	 $s3="" if (not defined $RAND or $RAND<=1) and $EQUAL<=1;
  my $sf = " $CC_$KFMT{$k}$CD_"; $sf="" if not defined $KFMT{$k};
  verbose "$ii key","$CW_$kk$s1$s2$s3$sf"; }

exit 1 if not $ok;

# ---------------------------------------------------------------------------- EVALUATOR
# include "journal.pl"
# include "logs.pl"

sub evaluate {
  my  $ti = $_[0]; # index of eq/rand test for given A
  my   $a = $_[1]; # the A value, for substitution in journal/logfiles paths
  my $GKV = $_[2]; # arrays of arrays of all (multiple-files multiple-tests) values for each key
  my $GKA = $_[3]; # array A-values for all tests
  my %GKU;	   # units for each key

  # store A for each test
  $$GKA[$ti] = $a;

  # parse journals and logs
  foreach my $p (@PJRN,@PLOG) {
    my %kv;
    my $path = $p;
    $path =~ s/$PAR1/$a/g; # substitution

    # get
    if(inar \@PJRN,$p) { readjournal $path,\%kv,\%GKU; }
    else	       { readlog $path,\%kv; }

    # store
    foreach my $k (@KEYS) {
      next if not defined $kv{$k};
      push @{$$GKV{$k}[$ti]},$kv{$k}; }}}

# ---------------------------------------------------------------------------- MAIN LOOP
# include "logline.pl"

# A-iterations
my $Ar = 1; # realized iterations
my $Ai = 1; # base iterations including skipped due to precision test etc.
my $Ab = 0; # batch iterations

# correct A1 to ABINC
if($ABINC and defined $A1) { $Ab+=$ABINC while $Ab<=$A1; }

# start A
my $A = 1;
$A = $A1 if defined $A1;

# previous A
my $Alast = $A;

# loop itself
print STDERR "\n" if $QUERY or not $VERBOSE;
while(1) {

  # decimal precision
  my $Aout = sprintf "%.${APREC}f",$A;
  my $Arnd = $Aout; # for randomization

  # concurrent runs
  my %KV; # arrays of values for each key
  my $rn = 1; $rn = $RAND if defined $RAND and $RAND>=1; # number of randomized runs

  # randomization loop
  my %GKV;  # arrays of arrays of all (multiple-files multiple-tests) values for each key
  my @GKA;  # array A-values for all tests
  my $ti=0; # total rand+eq index
  for(my $ri=0; $ri<$rn; $ri++) {

    # randomization shift Arnd=Aout-RAD+rnd
    my $rad = $RAD;
       $rad = $Aout * $1/100 if $RAD =~ /^(.*)%$/;
       $rad = $RADMAX if defined $RADMAX and $rad>$RADMAX;
    my $srnd;
    if(defined $RAND and $RAND>=1) {
      my $rnd = rand(2*$rad);
      my $arnd = $Aout-$rad+$rnd;
      $Arnd = sprintf "%.${APREC}f",$arnd;
      $Arnd = $A2 if defined $A2 and $Arnd > $A2;
      $Arnd = $A1 if defined $A1 and $Arnd < $A1;
      $Arnd = 1 if not defined $A1 and $Arnd < 1;
      $srnd = sprintf " Arnd=$Aout-$rad+%.3f=%.3f=$CD_$Arnd",$rnd,$arnd; }

    # equal-runs loop
    for(my $ei=0; $ei<$EQUAL; $ei++) {

      # program
      my $prog = $PROG[0];
      my @args;
      for(my $i=1; $i<=$#PROG; $i++) {
	my $s = $PROG[$i];
	$s =~ s/$PAR1/$Arnd/g; # for substitution use the randomized-A
	push @args,$s; }

      # report
      print STDERR "\n" if $VERBOSE and not $QUERY;
      if($VERBOSE and ($EQUAL>1 or (defined $RAND and $RAND>=1))) {
	my $se; $se = sprintf " equal=%s",fth($ei+1) if $EQUAL>1;
	my $sr; $sr = sprintf " randomized=%s",fth($ri+1) if defined $RAND and $RAND>=1;
	printf STDERR "${CK_}test=%s$sr$se$CD_\n",fth($Ar); }
      printf STDERR "${CK_}Ar=$Ar Ai=$Ai A=%.3f Aout=$CD_$Aout$CK_ Ab=$Ab$srnd$CD_\n",$A if $DEBUG;

      my $cmd = $prog;
      $cmd .= " $_" foreach @args;
      printf STDERR "$CM_%s$CD_\n",$cmd;

      # run									 <== RUN
      if(not $QUERY) {
	usleep(1000000*$SLEEP) if defined $SLEEP;
	system2 $prog,@args;
	evaluate $ti++,$Arnd,\%GKV,\@GKA; }}} # randomized A to correspond with how program was called

  # save results                                                                <== SAVE
  logline $Aout,\%GKV,\@GKA if not $QUERY;

  # logarithmic next A,Ab
  if($ALOG) {
    while(1) {
      $Ai++;
      $A = $ABASE ** $Ai;
      my $aout = sprintf "%.${APREC}f",$A;
      if($ABINC) {
	if($aout >= $Ab) {
	  $Ab += $ABINC while $Ab < $aout;
	  last; }}
      else {
	last if $aout > $Aout; }}}

  # linear next A,Ab
  else {
    if(defined $ASTEP) { $A += $ASTEP; }
    else	       { $A ++; }
    $Ai++; }

  # at-batch stops
  $A = $Ab-$ABINC if defined $ABAT;

  # next Ar
  $Ar++;

  # stop on A
  if(defined $A2 and $A>$A2) { last; }

  # stop on Ai
  if(defined $ASTEPS and $Ar>$ASTEPS) { last; }

  $Alast = $Aout; }

print STDERR "\n";
# --------------------------------------------------------------------------------------
